import requests
import json
import os
from datetime import datetime

# Config
OPENAPI_URL = "http://localhost:8001/openapi.json"
OUTPUT_FILE = "../frontend/src/api/schema.js"

def fetch_openapi_spec():
    try:
        print(f"Fetching OpenAPI Spec from {OPENAPI_URL}...")
        response = requests.get(OPENAPI_URL)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Error fetching spec: {e}")
        return None

def generate_js_schema(spec):
    schemas = spec.get('components', {}).get('schemas', {})
    
    # [Manual Injection] Check if Candle exists, if not, inject it for "Side-by-Side" safety
    if 'Candle' not in schemas:
        print("Injecting Manual 'Candle' schema (Backend uses Dict currently)...")
        schemas['Candle'] = {
            "title": "Candle",
            "properties": {
                "timestamp": {"type": "string", "format": "date-time"},
                "open": {"type": "number"},
                "high": {"type": "number"},
                "low": {"type": "number"},
                "close": {"type": "number"},
                "volume": {"type": "integer"}
            }
        }
    
    js_content = [
        "/**",
        " * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY",
        " * Generated by tools/generate_frontend_client.py",
        f" * Timestamp: {datetime.now().isoformat()}",
        " */",
        "",
        "// Utility to parse dates safely",
        "const parseDate = (val) => {",
        "    if (!val) return 0;",
        "    if (typeof val === 'number') return val;",
        "    return new Date(val).getTime() / 1000;",
        "};",
        ""
    ]

    for model_name, model_def in schemas.items():
        props = model_def.get('properties', {})
        
        js_content.append(f"/**")
        js_content.append(f" * Transformer for {model_name}")
        js_content.append(f" * @param {{Object}} data - Raw API response")
        js_content.append(f" * @returns {{Object}} Normalized for UI")
        js_content.append(f" */")
        js_content.append(f"export const normalize{model_name} = (data) => ({{")
        
        for prop_name, prop_def in props.items():
            # Auto-detection for Mapping Logic
            val_expr = f"data.{prop_name}"
            
            # 1. Timestamp Mapping Strategy (The Core Fix)
            if prop_name == 'timestamp':
                # Map 'timestamp' (Backend) -> 'time' (UI Standard)
                js_content.append(f"    time: parseDate(data.{prop_name}), // Auto-mapped from timestamp")
                # Also keep original just in case
                js_content.append(f"    original_timestamp: data.{prop_name},")
                continue
            
            # 2. Date Mapping
            if 'date' in prop_name.lower() or prop_def.get('format') == 'date-time':
                pass # Optionally handle other dates
            
            # Standard Property
            js_content.append(f"    {prop_name}: {val_expr},")
            
        js_content.append("});")
        js_content.append("")

    return "\n".join(js_content)

def main():
    spec = fetch_openapi_spec()
    if not spec:
        print("Failed to get spec. Ensure Backend is running on port 8001.")
        return

    js_code = generate_js_schema(spec)
    
    # Save
    tgt_path = os.path.join(os.path.dirname(__file__), OUTPUT_FILE)
    os.makedirs(os.path.dirname(tgt_path), exist_ok=True)
    
    with open(tgt_path, 'w') as f:
        f.write(js_code)
        
    print(f"Successfully generated schema at: {tgt_path}")

if __name__ == "__main__":
    main()
